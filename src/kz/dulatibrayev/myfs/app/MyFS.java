package kz.dulatibrayev.myfs.app;

import java.io.File;
import java.util.Scanner;

public class MyFS {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);

		boolean running = true;

		try {

			while (running) {
				System.out.print("> ");
				String command = scanner.nextLine();
				String[] commands = command.split(" ");

				switch (commands[0]) {

				case "setmod": {
					setmod(commands[1], commands[2]);
					break;
				}

				case "readmod": {
					readmod(commands[1]);
					break;
				}

				case "define": {
					define(commands[1]);
					break;
				}

				case "is_dir": {
					System.out.println(is_dir(commands[1]));
					break;
				}
				case "ls_py": {
					ls_py(commands[1]);
					System.out.println("");
					break;
				}

				case "ls": {
					ls(commands[1]);
					System.out.println("");
					break;
				}

				case "exit": {
					System.out.println("Exit from MyFS");
					running = false;
					break;
				}
				case "help": {
					System.out.println(HELP_MSG);
					break;
				}

				default:
					System.out.println("Doesn't recognized command, please try again or use help");
				}

			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static void setmod(String path, String permissions) {
		File file = new File(path);
		String[] arrModes = permissions.split("");

		boolean readeable = (arrModes[0].equalsIgnoreCase("r")) ? file.setReadable(true) : file.setReadable(false);
		boolean writable = (arrModes[1].equalsIgnoreCase("w")) ? file.setReadable(true) : file.setReadable(false);
		boolean exacutable = (arrModes[2].equalsIgnoreCase("x")) ? file.setReadable(true) : file.setReadable(false);

		file.setReadable(readeable);
		file.setWritable(writable);
		file.setExecutable(exacutable);

		System.out.print("Current rights - ");
		readmod(path);

	}

	public static void readmod(String path) {
		File file = new File(path);
		StringBuilder builder = new StringBuilder();

		if (file.canRead()) {
			builder.append("R");
		}
		if (file.canWrite()) {
			builder.append("W");
		}
		if (file.canExecute()) {
			builder.append("X");
		}
		System.out.println(builder.toString());

	}

	public static void define(String path) {
		File file = new File(path);
		if (file.isDirectory()) {
			System.out.println("directory");
		} else {
			System.out.println("file");
		}
	}

	public static boolean is_dir(String path) {
		File file = new File(path);
		return file.isDirectory();
	}

	public static void ls_py(String path) {
		String extension = ".py";
		File directory = new File(path);
		File[] files = directory.listFiles();

		if (files != null) {
			for (File file : files) {
				if (file.isFile() && file.getName().endsWith(extension)) {
					System.out.println(file.getName());
				}
			}
		} else {
			System.out.println("Error: Unable to list files in the current directory.");
		}
	}

	public static void ls(String path) {
		File file = new File(path);
		File[] files = file.listFiles();

		if (files != null) {
			for (int i = 0; i < files.length; i++) {
				File tempFileName = files[i];
				if (tempFileName.isFile()) {
					System.out.print(tempFileName.getName() + " ");
				}
			}
		}

	}

	private static final String HELP_MSG = "ls <path>               выводит список всех файлов и директорий для `path`\r\n"
			+ "ls_py <path>            выводит список файлов с расширением `.py` в `path`\r\n"
			+ "is_dir <path>           выводит `true`, если `path` это директория, в других случаях `false`\r\n"
			+ "define <path>           выводит `директория` или `файл` в зависимости от типа `path`\r\n"
			+ "readmod <path>          выводит права для файла в формате `rwx` для текущего пользователя\r\n"
			+ "setmod <path> <perm>    устанавливает права для файла `path`\r\n"
			+ "cat <path>              выводит контент файла\r\n"
			+ "append <path>           добавляет строку `# Autogenerated line` в конец `path`\r\n"
			+ "bc <path>               создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`\r\n"
			+ "greplong <path>         выводит самое длинное слово в файле\r\n"
			+ "help                    выводит список команд и их описание\r\n"
			+ "exit                    завершает работу программы";
}
